---
description: 
globs: 
alwaysApply: true
---
1. Code Style
	•	Always prefer explicit and descriptive code over short unclear expressions.
	•	Use async/await instead of .then()/.catch() for asynchronous code.
	•	Keep functions pure whenever possible.
	•	Prefer functional programming patterns over imperative ones when reasonable.
	•	Maintain consistent code formatting according to project linters (e.g., Prettier, ESLint).
	•	Never use console.log for debugging; prefer structured error handling or proper logging libraries.
	•	Follow naming conventions: camelCase for variables and functions, PascalCase for classes and components.
	•	Always destructure objects in function parameters when possible.
	•	Use const over let unless reassignment is required.

2. Documentation
	•	Always add a brief JSDoc comment to public functions, classes, and complex logic.
	•	When creating new APIs or services, generate documentation automatically where possible.

3. Tests
	•	For any new function, if complexity is medium or high, suggest generating unit tests automatically.
	•	Prioritize coverage of edge cases in test generation.
	•	Avoid writing trivial tests that only duplicate the implementation.

4. Refactoring
	•	When refactoring, prioritize readability, then performance.
	•	Split large functions into smaller pure functions when exceeding 30–40 lines.
	•	If a component or function grows beyond a single clear responsibility, suggest separation.
	•	Avoid introducing breaking changes unless explicitly instructed.

5. File and Project Structure
	•	Respect the existing project folder and module structure.
	•	When adding a new feature, suggest creating a dedicated folder/module if logical grouping is required.
	•	Reuse existing utilities and hooks before suggesting new ones.

6. Communication with the User
	•	Before applying major changes, confirm the intention by proposing a plan.
	•	Ask clarifying questions if the task is ambiguous or could have multiple interpretations.
	•	Prefer providing 2–3 alternative solutions for major architectural or refactoring decisions.

7. Error Handling
	•	Never silently catch errors without handling or rethrowing them.
	•	Add meaningful error messages when throwing custom errors.
	•	Suggest centralizing error management when recurring patterns are detected.

8. Security
	•	Always validate and sanitize user inputs in APIs and database operations.
	•	Never expose sensitive data such as passwords, tokens, or internal server errors.

9. Performance
	•	Optimize database queries, API calls, and rendering performance if potential bottlenecks are detected.
	•	Avoid premature optimization unless a clear performance issue exists.

10. AI Usage Behavior
	•	Prioritize lightweight and incremental changes over large, complex rewrites.
	•	When in doubt, prefer stability and maintainability over innovation.